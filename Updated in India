#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Enhanced 5-10 EMA Cross Trading Bot - AWS Version
Based on working Colab version + Discord alerts + AWS compatibility
"""

import os
import sys
import pandas as pd
import numpy as np
import asyncio
import logging
import time
import threading
from datetime import datetime, timedelta
from collections import deque
from typing import Dict, Optional
import warnings
import requests
import pytz
import signal
import schedule

warnings.filterwarnings('ignore')

# ============================================================================
# CONFIGURATION - PUT YOUR CREDENTIALS HERE
# ============================================================================
ALPACA_API_KEY = "PK4SNFKPNS485S0LRZ0Y"
ALPACA_SECRET_KEY = "Zt1mZLm3GANReXk21h0krQqRRdl83WGhUONHHz2C"
ALPACA_BASE_URL = "https://paper-api.alpaca.markets"  # Use paper trading

DISCORD_WEBHOOK_URL = "https://discord.com/api/webhooks/1423311843019194450/_7q91XG0OA6q7Ctdoyr3WZzdTPo1KjH6XUtjC18jSYQMHOiXjWqM5Dq-sRXyHEofjjcW"
# ============================================================================

# ============================================================================
# LOGGING
# ============================================================================
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[
        logging.FileHandler("/var/log/trading_bot.log"),
        logging.StreamHandler(sys.stdout)
    ]
)
logger = logging.getLogger(__name__)

# Import Alpaca
try:
    import alpaca_trade_api as tradeapi
    from alpaca_trade_api.stream import Stream
    ALPACA_AVAILABLE = True
    logger.info("‚úì Alpaca Trade API loaded")
except ImportError as e:
    logger.error(f"‚úó Alpaca import failed: {e}")
    sys.exit(1)


# ============================================================================
# DISCORD ALERTS
# ============================================================================
daily_trades = []

def send_discord_embed(message, title="Trading Bot", color=3447003, fields=None):
    """Send rich embed to Discord"""
    if not DISCORD_WEBHOOK_URL:
        return
    
    embed = {
        "title": title,
        "description": message,
        "color": color,
        "timestamp": datetime.utcnow().isoformat(),
        "footer": {"text": "Enhanced EMA Bot - AWS"}
    }
    
    if fields:
        embed["fields"] = fields
    
    try:
        requests.post(DISCORD_WEBHOOK_URL, json={"embeds": [embed]}, timeout=10)
    except:
        pass


def bot_start_alert(bot):
    """Alert when bot starts"""
    try:
        account = bot.api.get_account()
        portfolio = float(account.portfolio_value)
        
        fields = [
            {"name": "üí∞ Portfolio", "value": f"${portfolio:,.2f}", "inline": True},
            {"name": "üéØ Threshold", "value": str(bot.signal_threshold), "inline": True}
        ]
        
        send_discord_embed(
            "‚úÖ Trading bot started on AWS",
            title="ü§ñ Bot Started",
            color=3066993,
            fields=fields
        )
    except:
        pass


def trade_open_alert(symbol, side, entry_price, qty):
    """Alert when opening trade"""
    trade = {
        "symbol": symbol,
        "side": side,
        "entry": entry_price,
        "exit": None,
        "qty": qty,
        "pl": None,
        "open_time": datetime.now().strftime("%H:%M:%S"),
        "open_datetime": datetime.now()
    }
    daily_trades.append(trade)
    
    fields = [
        {"name": "üíµ Entry", "value": f"${entry_price:.2f}", "inline": True},
        {"name": "üì¶ Quantity", "value": str(qty), "inline": True}
    ]
    
    send_discord_embed(
        f"üü¢ **BUY {symbol}**",
        title="üìà New Trade",
        color=3066993,
        fields=fields
    )


def trade_close_alert(symbol, exit_price, exit_reason="Manual"):
    """Alert when closing trade"""
    for trade in daily_trades:
        if trade["symbol"] == symbol and trade["exit"] is None:
            trade["exit"] = exit_price
            trade["exit_reason"] = exit_reason
            
            trade["pl"] = (exit_price - trade["entry"]) * trade["qty"]
            trade["pl_pct"] = ((exit_price - trade["entry"]) / trade["entry"]) * 100
            trade["duration"] = str(datetime.now() - trade["open_datetime"]).split('.')[0]
            
            result_emoji = "‚úÖ" if trade["pl"] > 0 else "‚ùå"
            
            fields = [
                {"name": "üí∞ P&L", "value": f"${trade['pl']:+,.2f}", "inline": True},
                {"name": "üìä P&L %", "value": f"{trade['pl_pct']:+.2f}%", "inline": True},
                {"name": "üö™ Exit", "value": exit_reason, "inline": True}
            ]
            
            send_discord_embed(
                f"{result_emoji} {symbol} closed",
                title="üíº Trade Closed",
                color=15105570 if trade["pl"] < 0 else 3066993,
                fields=fields
            )
            break


def hourly_status_alert(bot):
    """Hourly status update"""
    try:
        account = bot.api.get_account()
        portfolio = float(account.portfolio_value)
        active_positions = sum(1 for pos in bot.positions.values() if pos['qty'] != 0)
        
        fields = [
            {"name": "üí∞ Portfolio", "value": f"${portfolio:,.2f}", "inline": True},
            {"name": "üìä Positions", "value": str(active_positions), "inline": True},
            {"name": "üíº Trades", "value": str(bot.total_trades_executed), "inline": True}
        ]
        
        send_discord_embed(
            "üìä Bot running on AWS",
            title="‚è∞ Hourly Status",
            color=3447003,
            fields=fields
        )
    except:
        pass


def send_eod_summary():
    """End of day summary"""
    closed_trades = [t for t in daily_trades if t.get("pl") is not None]
    
    if not closed_trades:
        send_discord_embed("No trades today", title="üìä End of Day", color=9807270)
        daily_trades.clear()
        return
    
    total_pl = sum(t["pl"] for t in closed_trades)
    wins = sum(1 for t in closed_trades if t["pl"] > 0)
    losses = len(closed_trades) - wins
    
    fields = [
        {"name": "üìà Total Trades", "value": str(len(closed_trades)), "inline": True},
        {"name": "‚úÖ Wins", "value": str(wins), "inline": True},
        {"name": "‚ùå Losses", "value": str(losses), "inline": True},
        {"name": "üí∞ Total P&L", "value": f"${total_pl:+,.2f}", "inline": False}
    ]
    
    color = 3066993 if total_pl > 0 else 15105570
    title = "üìä End of Day - Profitable! ‚úÖ" if total_pl > 0 else "üìä End of Day - Loss ‚ùå"
    
    send_discord_embed(f"Total P&L: ${total_pl:+,.2f}", title=title, color=color, fields=fields)
    daily_trades.clear()


schedule.every().day.at("20:00").do(send_eod_summary)


# ============================================================================
# TRADING BOT CLASS - EXACT SAME AS WORKING VERSION
# ============================================================================

class LiveTradingBot:
    def __init__(self, initial_capital=250000, risk_per_trade=0.01):
        """Initialize the enhanced trading bot"""
        
        # Capital & Risk Management
        self.initial_capital = initial_capital
        self.risk_per_trade = risk_per_trade
        self.max_position_size = initial_capital * 0.15
        
        # Exit Parameters
        self.stop_loss = 0.008  # 0.8%
        self.take_profit_1 = 0.015  # 1.5%
        self.take_profit_2 = 0.025  # 2.5%
        self.trailing_stop = 0.005  # 0.5%
        
        # Signal Configuration
        self.signal_threshold = 4  # Lowered from 6 for more activity
        
        # Data Storage
        self.symbol_data = {}
        self.max_bars = 200
        self.positions = {}
        self.pending_orders = {}
        
        # Symbols to trade
        self.symbols = ['GOOGL', 'PDD', 'MSFT', 'APP', 'PEP', 'AVGO', 'RDDT', 'CAT', 'LMT']
        
        # Status tracking
        self.bot_start_time = datetime.now()
        self.last_activity_time = datetime.now()
        self.last_hourly_alert = datetime.now()
        self.total_bars_received = 0
        self.total_signals_generated = 0
        self.total_trades_executed = 0
        self.is_running = False
        self.status_thread = None
        
        # Statistics
        self.stats = {
            'bars_per_symbol': {},
            'signals_per_symbol': {},
            'trades_per_symbol': {},
            'last_price_per_symbol': {},
            'connection_status': 'Disconnected',
            'sl_exits': 0,
            'pt_exits': 0,
            'after_hours_bars': 0,
            'market_hours_bars': 0
        }
        
        # Initialize tracking for each symbol
        for symbol in self.symbols:
            self.symbol_data[symbol] = deque(maxlen=self.max_bars)
            self.positions[symbol] = {
                'qty': 0,
                'entry_price': 0,
                'entry_time': None,
                'highest_price': 0,
                'type': None
            }
            self.stats['bars_per_symbol'][symbol] = 0
            self.stats['signals_per_symbol'][symbol] = 0
            self.stats['trades_per_symbol'][symbol] = 0
            self.stats['last_price_per_symbol'][symbol] = 0.0
        
        # Setup connections
        self.api = None
        self.stream = None
        self.setup_alpaca_connection()

    def is_market_hours(self) -> bool:
        """Check if current time is during market hours (9:30 AM - 4:00 PM ET)"""
        try:
            eastern = pytz.timezone('US/Eastern')
            now_et = datetime.now(eastern)
            
            # Check if weekend
            if now_et.weekday() >= 5:  # Saturday=5, Sunday=6
                return False
            
            # Market hours: 9:30 AM - 4:00 PM ET
            market_open = now_et.replace(hour=9, minute=30, second=0, microsecond=0)
            market_close = now_et.replace(hour=16, minute=0, second=0, microsecond=0)
            
            return market_open <= now_et <= market_close
            
        except Exception as e:
            logger.error(f"Error checking market hours: {e}")
            return True

    def setup_alpaca_connection(self):
        """Setup connection to Alpaca API"""
        if not ALPACA_AVAILABLE:
            logger.error("Alpaca API not available")
            return
        
        try:
            self.api = tradeapi.REST(
                key_id=ALPACA_API_KEY,
                secret_key=ALPACA_SECRET_KEY,
                base_url=ALPACA_BASE_URL
            )
            
            # Test connection
            account = self.api.get_account()
            logger.info(f"‚úì Connected to Alpaca - Account Status: {account.status}")
            
            # Setup streaming
            self.stream = Stream(
                ALPACA_API_KEY,
                ALPACA_SECRET_KEY,
                base_url=ALPACA_BASE_URL,
                data_feed='iex'
            )
            
        except Exception as e:
            logger.error(f"Failed to connect to Alpaca: {e}")
            self.api = None
            self.stream = None

    def calculate_indicators(self, symbol: str) -> Optional[Dict]:
        """Calculate technical indicators for a symbol"""
        if symbol not in self.symbol_data or len(self.symbol_data[symbol]) < 50:
            return None
        
        bars_list = list(self.symbol_data[symbol])
        df = pd.DataFrame(bars_list)
        
        if df.empty or len(df) < 50:
            return None
        
        try:
            # EMAs
            df['EMA_5'] = df['close'].ewm(span=5, adjust=False).mean()
            df['EMA_10'] = df['close'].ewm(span=10, adjust=False).mean()
            df['EMA_20'] = df['close'].ewm(span=20, adjust=False).mean()
            df['EMA_50'] = df['close'].ewm(span=50, adjust=False).mean()
            
            # MACD
            exp1 = df['close'].ewm(span=12, adjust=False).mean()
            exp2 = df['close'].ewm(span=26, adjust=False).mean()
            df['MACD'] = exp1 - exp2
            df['MACD_signal'] = df['MACD'].ewm(span=9, adjust=False).mean()
            df['MACD_histogram'] = df['MACD'] - df['MACD_signal']
            
            # RSI
            delta = df['close'].diff()
            gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()
            loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()
            rs = gain / loss
            df['RSI'] = 100 - (100 / (1 + rs))
            
            # ATR
            df['high_low'] = df['high'] - df['low']
            df['high_close'] = abs(df['high'] - df['close'].shift())
            df['low_close'] = abs(df['low'] - df['close'].shift())
            df['tr'] = df[['high_low', 'high_close', 'low_close']].max(axis=1)
            df['ATR'] = df['tr'].rolling(window=14).mean()
            
            # Volume
            df['volume_sma'] = df['volume'].rolling(window=20).mean()
            df['volume_ratio'] = df['volume'] / df['volume_sma']
            
            # Get latest and previous values
            latest = df.iloc[-1]
            prev = df.iloc[-2] if len(df) > 1 else latest
            
            return {
                'close': latest['close'],
                'EMA_5': latest['EMA_5'],
                'EMA_10': latest['EMA_10'],
                'EMA_20': latest['EMA_20'],
                'EMA_50': latest['EMA_50'],
                'MACD': latest['MACD'],
                'MACD_signal': latest['MACD_signal'],
                'MACD_histogram': latest['MACD_histogram'],
                'RSI': latest['RSI'],
                'ATR': latest['ATR'],
                'volume_ratio': latest['volume_ratio'],
                'prev_EMA_5': prev['EMA_5'],
                'prev_EMA_10': prev['EMA_10'],
                'prev_MACD': prev['MACD'],
                'prev_MACD_signal': prev['MACD_signal']
            }
            
        except Exception as e:
            logger.error(f"Error calculating indicators for {symbol}: {e}")
            return None

    def generate_signal(self, symbol: str, indicators: Dict) -> int:
        """Generate trading signal based on indicators"""
        try:
            # Crossover detection
            ema_5_cross_above = (
                indicators['EMA_5'] > indicators['EMA_10'] and
                indicators['prev_EMA_5'] <= indicators['prev_EMA_10']
            )
            ema_5_cross_below = (
                indicators['EMA_5'] < indicators['EMA_10'] and
                indicators['prev_EMA_5'] >= indicators['prev_EMA_10']
            )
            
            # MACD conditions
            macd_bullish = indicators['MACD'] > indicators['MACD_signal']
            macd_bearish = indicators['MACD'] < indicators['MACD_signal']
            
            # Price position
            price_above_20ema = indicators['close'] > indicators['EMA_20']
            price_below_20ema = indicators['close'] < indicators['EMA_20']
            
            # RSI filter
            rsi_neutral = 30 < indicators['RSI'] < 70
            
            # Volume confirmation
            volume_above_avg = indicators['volume_ratio'] > 1.1
            
            # Trend strength
            strong_uptrend = (
                indicators['EMA_5'] > indicators['EMA_10'] >
                indicators['EMA_20'] > indicators['EMA_50']
            )
            strong_downtrend = (
                indicators['EMA_5'] < indicators['EMA_10'] <
                indicators['EMA_20'] < indicators['EMA_50']
            )
            
            # Calculate scores
            buy_score = 0
            sell_score = 0
            
            # Buy signals
            if ema_5_cross_above:
                buy_score += 3
            if macd_bullish:
                buy_score += 2
            if price_above_20ema:
                buy_score += 1
            if strong_uptrend:
                buy_score += 2
            if rsi_neutral:
                buy_score += 1
            if volume_above_avg:
                buy_score += 1
            
            # Sell signals
            if ema_5_cross_below:
                sell_score += 3
            if macd_bearish:
                sell_score += 2
            if price_below_20ema:
                sell_score += 1
            if strong_downtrend:
                sell_score += 2
            if rsi_neutral:
                sell_score += 1
            if volume_above_avg:
                sell_score += 1
            
            # Track signal generation
            if buy_score >= self.signal_threshold or sell_score >= self.signal_threshold:
                self.total_signals_generated += 1
                self.stats['signals_per_symbol'][symbol] += 1
            
            # Return signal
            if buy_score >= self.signal_threshold:
                logger.info(f"üü¢ BUY SIGNAL: {symbol} | Score: {buy_score}/{self.signal_threshold} | "
                          f"RSI: {indicators['RSI']:.1f} | Price: ${indicators['close']:.2f}")
                return 1
            elif sell_score >= self.signal_threshold:
                logger.info(f"üî¥ SELL SIGNAL: {symbol} | Score: {sell_score}/{self.signal_threshold} | "
                          f"RSI: {indicators['RSI']:.1f} | Price: ${indicators['close']:.2f}")
                return -1
            else:
                return 0
                
        except Exception as e:
            logger.error(f"Error generating signal for {symbol}: {e}")
            return 0

    def calculate_position_size(self, symbol: str, current_price: float, atr: float) -> int:
        """Calculate position size based on risk management"""
        try:
            account = self.api.get_account()
            buying_power = float(account.buying_power)
            
            risk_amount = min(
                buying_power * self.risk_per_trade,
                self.max_position_size * self.risk_per_trade
            )
            
            stop_distance = max(atr * 2, current_price * self.stop_loss)
            position_size = int(risk_amount / stop_distance)
            
            max_shares = int(self.max_position_size / current_price)
            position_size = min(position_size, max_shares)
            
            max_affordable = int(buying_power * 0.95 / current_price)
            position_size = min(position_size, max_affordable)
            
            return max(position_size, 0)
            
        except Exception as e:
            logger.error(f"Error calculating position size for {symbol}: {e}")
            return 0

    def place_order(self, symbol: str, qty: int, side: str, current_price: float) -> Optional[str]:
        """Place order with Alpaca"""
        try:
            if qty <= 0:
                logger.warning(f"Invalid quantity for {symbol}: {qty}")
                return None
            
            order = self.api.submit_order(
                symbol=symbol,
                qty=qty,
                side=side,
                type='market',
                time_in_force='day'
            )
            
            logger.info(f"üì§ ORDER PLACED: {side.upper()} {qty} shares of {symbol} at ~${current_price:.2f}")
            
            self.total_trades_executed += 1
            self.stats['trades_per_symbol'][symbol] += 1
            
            self.pending_orders[symbol] = {
                'order_id': order.id,
                'side': side,
                'qty': qty,
                'price': current_price,
                'timestamp': datetime.now()
            }
            
            if side.lower() == 'buy':
                trade_open_alert(symbol, side, current_price, qty)
            
            return order.id
            
        except Exception as e:
            logger.error(f"Error placing order for {symbol}: {e}")
            return None

    def check_exit_conditions(self, symbol: str, current_price: float) -> Optional[str]:
        """Check if position should be exited (SL/PT/Trailing)"""
        position = self.positions[symbol]
        
        if position['qty'] == 0:
            return None
        
        try:
            if position['type'] == 'LONG':
                if current_price > position['highest_price']:
                    position['highest_price'] = current_price
                
                pnl_pct = (current_price - position['entry_price']) / position['entry_price']
                
                if pnl_pct <= -self.stop_loss:
                    self.stats['sl_exits'] += 1
                    return "Stop Loss"
                
                if pnl_pct >= self.take_profit_2:
                    self.stats['pt_exits'] += 1
                    return "Take Profit 2"
                
                if pnl_pct >= self.take_profit_1:
                    self.stats['pt_exits'] += 1
                    return "Take Profit 1"
                
                if pnl_pct > 0.005:
                    if current_price < position['highest_price'] * (1 - self.trailing_stop):
                        return "Trailing Stop"
            
            return None
            
        except Exception as e:
            logger.error(f"Error checking exit conditions for {symbol}: {e}")
            return None

    def update_position(self, symbol: str, qty: int, price: float, side: str):
        """Update internal position tracking"""
        position = self.positions[symbol]
        
        if side == 'buy':
            position['qty'] = qty
            position['entry_price'] = price
            position['entry_time'] = datetime.now()
            position['highest_price'] = price
            position['type'] = 'LONG'
            
            logger.info(f"‚úÖ LONG POSITION OPENED: {qty} shares of {symbol} at ${price:.2f}")
            
        elif side == 'sell':
            if position['qty'] > 0:
                pnl = position['qty'] * (price - position['entry_price'])
                pnl_pct = (price - position['entry_price']) / position['entry_price'] * 100
                
                logger.info(f"‚úÖ POSITION CLOSED: {symbol} | P&L: ${pnl:.2f} ({pnl_pct:+.2f}%)")
            
            position['qty'] = 0
            position['entry_price'] = 0
            position['entry_time'] = None
            position['highest_price'] = 0
            position['type'] = None

    async def bar_callback(self, bar):
        """Handle incoming bar data"""
        try:
            symbol = bar.symbol
            
            self.last_activity_time = datetime.now()
            self.total_bars_received += 1
            self.stats['bars_per_symbol'][symbol] += 1
            self.stats['last_price_per_symbol'][symbol] = bar.close
            
            if self.is_market_hours():
                self.stats['market_hours_bars'] += 1
            else:
                self.stats['after_hours_bars'] += 1
            
            bar_data = {
                'timestamp': bar.timestamp,
                'open': bar.open,
                'high': bar.high,
                'low': bar.low,
                'close': bar.close,
                'volume': bar.volume
            }
            self.symbol_data[symbol].append(bar_data)
            
            indicators = self.calculate_indicators(symbol)
            if not indicators:
                return
            
            current_price = bar.close
            
            # Check exit conditions (24/7)
            exit_reason = self.check_exit_conditions(symbol, current_price)
            if exit_reason and self.positions[symbol]['qty'] != 0:
                logger.info(f"üö™ EXIT: {symbol} - {exit_reason} | ${current_price:.2f}")
                
                qty = abs(self.positions[symbol]['qty'])
                order_id = self.place_order(symbol, qty, 'sell', current_price)
                
                if order_id:
                    trade_close_alert(symbol, current_price, exit_reason)
                    self.update_position(symbol, 0, current_price, 'sell')
                return
            
            # Entry signals (only during market hours)
            if self.positions[symbol]['qty'] == 0 and self.is_market_hours():
                signal = self.generate_signal(symbol, indicators)
                
                if signal == 1:  # BUY
                    qty = self.calculate_position_size(symbol, current_price, indicators['ATR'])
                    
                    if qty > 0:
                        order_id = self.place_order(symbol, qty, 'buy', current_price)
                        if order_id:
                            self.update_position(symbol, qty, current_price, 'buy')
            
            # Hourly status
            if (datetime.now() - self.last_hourly_alert).total_seconds() >= 3600:
                hourly_status_alert(self)
                self.last_hourly_alert = datetime.now()
            
            # EOD summary
            schedule.run_pending()
            
        except Exception as e:
            logger.error(f"Error in bar callback for {bar.symbol}: {e}")

    def print_status_aws(self):
        """AWS-friendly status display"""
        while self.is_running:
            try:
                current_time = datetime.now()
                uptime = current_time - self.bot_start_time
                
                market_open = self.is_market_hours()
                market_status = "üü¢ OPEN" if market_open else "üî¥ CLOSED"
                
                try:
                    account = self.api.get_account()
                    portfolio_value = float(account.portfolio_value)
                    buying_power = float(account.buying_power)
                except:
                    portfolio_value = 0
                    buying_power = 0
                
                active_positions = sum(1 for pos in self.positions.values() if pos['qty'] != 0)
                
                logger.info("=" * 80)
                logger.info(f"ü§ñ BOT STATUS | {current_time.strftime('%Y-%m-%d %H:%M:%S')} | Market: {market_status}")
                logger.info(f"Uptime: {str(uptime).split('.')[0]} | Connection: {self.stats['connection_status']}")
                logger.info(f"Portfolio: ${portfolio_value:,.2f} | Buying Power: ${buying_power:,.2f}")
                logger.info(f"Active Positions: {active_positions}")
                logger.info(f"Bars: {self.total_bars_received:,} | Signals: {self.total_signals_generated} | Trades: {self.total_trades_executed}")
                logger.info(f"SL Exits: {self.stats['sl_exits']} | PT Exits: {self.stats['pt_exits']}")
                logger.info("=" * 80)
                
                time.sleep(300)  # Log status every 5 minutes
                
            except Exception as e:
                logger.error(f"Error in status display: {e}")
                time.sleep(300)

    def start_status_monitor(self):
        """Start the status monitoring thread"""
        self.status_thread = threading.Thread(target=self.print_status_aws, daemon=True)
        self.status_thread.start()

    def start_streaming(self):
        """Start live data streaming"""
        if not self.stream:
            logger.error("Stream not initialized")
            return
        
        self.is_running = True
        self.start_status_monitor()
        
        try:
            for symbol in self.symbols:
                self.stream.subscribe_bars(self.bar_callback, symbol)
            
            logger.info(f"üöÄ Streaming started for {len(self.symbols)} symbols")
            logger.info(f"   Running on AWS EC2")
            logger.info(f"   Signal Threshold: {self.signal_threshold}")
            
            self.stats['connection_status'] = 'Streaming'
            self.stream.run()
            
        except KeyboardInterrupt:
            self.is_running = False
            logger.info("\nüõë Bot stopped by user")
        except Exception as e:
            logger.error(f"Stream error: {e}")
            self.stats['connection_status'] = 'Error'

    def sync_positions(self):
        """Sync with existing Alpaca positions"""
        try:
            positions = self.api.list_positions()
            
            if positions:
                logger.info("üìä Syncing existing positions...")
            
            for pos in positions:
                symbol = pos.symbol
                qty = int(float(pos.qty))
                avg_entry = float(pos.avg_entry_price)
                current_price = float(pos.current_price)
                
                if symbol in self.positions:
                    self.positions[symbol]['qty'] = qty
                    self.positions[symbol]['entry_price'] = avg_entry
                    self.positions[symbol]['entry_time'] = datetime.now()
                    self.positions[symbol]['highest_price'] = current_price
                    self.positions[symbol]['type'] = 'LONG' if qty > 0 else None
                    
                    logger.info(f"‚úì {symbol}: {qty} shares @ ${avg_entry:.2f}")
                
        except Exception as e:
            logger.error(f"Error syncing positions: {e}")


# ============================================================================
# GRACEFUL SHUTDOWN HANDLER
# ============================================================================

bot_instance = None

def signal_handler(signum, frame):
    """Handle shutdown signals gracefully"""
    logger.info("\nüõë Shutdown signal received")
    if bot_instance:
        bot_instance.is_running = False
    sys.exit(0)

signal.signal(signal.SIGINT, signal_handler)
signal.signal(signal.SIGTERM, signal_handler)


# ============================================================================
# MAIN FUNCTION
# ============================================================================

def run_aws_bot():
    global bot_instance
    
    logger.info("=" * 80)
    logger.info("ü§ñ ENHANCED EMA TRADING BOT - AWS EC2")
    logger.info("=" * 80)
    
    bot_instance = LiveTradingBot(initial_capital=250000, risk_per_trade=0.01)
    
    if not bot_instance.api:
        logger.error("‚ùå Cannot start bot - Alpaca connection failed")
        return
    
    # Send Discord start alert
    bot_start_alert(bot_instance)
    
    # Sync existing positions
    bot_instance.sync_positions()
    
    is_paper = "paper-api" in ALPACA_BASE_URL.lower()
    mode = "üìù PAPER TRADING" if is_paper else "üî¥ LIVE TRADING"
    
    logger.info(f"\nACCOUNT TYPE: {mode}")
    logger.info(f"API Endpoint: {ALPACA_BASE_URL}")
    logger.info(f"Market Status: {'üü¢ OPEN' if bot_instance.is_market_hours() else 'üî¥ CLOSED'}")
    
    logger.info("\n" + "=" * 80)
    logger.info("‚ö° BOT CONFIGURATION")
    logger.info("=" * 80)
    logger.info(f"‚úì Signal threshold: {bot_instance.signal_threshold}")
    logger.info(f"‚úì Stop Loss: {bot_instance.stop_loss*100:.1f}%")
    logger.info(f"‚úì Take Profit 1: {bot_instance.take_profit_1*100:.1f}%")
    logger.info(f"‚úì Take Profit 2: {bot_instance.take_profit_2*100:.1f}%")
    logger.info(f"‚úì Market hours filter: Entries only 9:30 AM - 4:00 PM ET")
    logger.info(f"‚úì Stop Loss exits: Active 24/7")
    logger.info(f"‚úì Discord alerts: Enabled")
    logger.info(f"‚úì Hourly updates: Every hour")
    logger.info(f"‚úì EOD summary: 8:00 PM ET")
    logger.info(f"‚úì All 9 symbols active")
    logger.info("=" * 80)
    
    logger.info("\nüöÄ Starting bot in 3 seconds...")
    logger.info("üì± Check Discord for alerts!")
    logger.info("üõë To stop: Ctrl+C or kill process")
    logger.info("=" * 80)
    
    time.sleep(3)
    
    try:
        bot_instance.start_streaming()
    except Exception as e:
        logger.error(f"Bot error: {e}")


if __name__ == "__main__":
    run_aws_bot()
